"""
G-code Generator for Hairbrush

This module provides functionality to generate G-code for a dual-airbrush plotter.
"""

import os
import math
import re


class GCodeGenerator:
    """Generate G-code for a dual-airbrush plotter."""
    
    def __init__(self):
        """Initialize the G-code generator."""
        self.output_lines = []
        self.viewbox = [0, 0, 100, 100]
        self.width = 100
        self.height = 100
        self.scale = 1.0
        self.offset_x = 0.0
        self.offset_y = 0.0
        self.current_brush = "brush_a"
        self.brush_config = {
            "brush_a": {"offset": (0, 0), "z_height": 2.0},
            "brush_b": {"offset": (0, 0), "z_height": 2.0}
        }
        self.debug_markers = False
    
    def set_svg_document_properties(self, viewbox, width, height):
        """Set the SVG document properties."""
        if viewbox:
            self.viewbox = viewbox
        if width:
            self.width = width
        if height:
            self.height = height
    
    def set_user_transform(self, scale=1.0, offset_x=0.0, offset_y=0.0):
        """Set user-defined transformations."""
        self.scale = scale
        self.offset_x = offset_x
        self.offset_y = offset_y
    
    def configure_brush(self, brush_id, config):
        """Configure a brush."""
        if brush_id in self.brush_config:
            for key, value in config.items():
                self.brush_config[brush_id][key] = value
        else:
            self.brush_config[brush_id] = config
    
    def enable_debug_markers(self, enable=True):
        """Enable or disable debug markers in G-code."""
        self.debug_markers = enable
    
    def add_header(self):
        """Add the G-code header."""
        self.output_lines.extend([
            "; Hairbrush G-code Export",
            "; Generated by Inkscape Extension",
            ";",
            "; SVG Document Properties:",
            f"; - ViewBox: {self.viewbox}",
            f"; - Width: {self.width}px",
            f"; - Height: {self.height}px",
            f"; - Scale: {self.scale}",
            f"; - X Offset: {self.offset_x}mm",
            f"; - Y Offset: {self.offset_y}mm",
            ";",
            "G21 ; Set units to millimeters",
            "G90 ; Use absolute coordinates",
            "G92 X0 Y0 Z0 ; Set current position as origin",
            "M84 S0 ; Disable stepper timeout",
            ""
        ])
    
    def add_footer(self):
        """Add the G-code footer."""
        self.output_lines.extend([
            "",
            "; End of G-code",
            "G1 Z10 F1000 ; Raise Z",
            "G1 X0 Y0 F3000 ; Return to origin",
            "M400 ; Wait for moves to finish",
            "M84 ; Disable motors"
        ])
    
    def add_path_with_attributes(self, path_data, stroke_color, stroke_width, stroke_opacity, base_feedrate):
        """Add a path to the G-code with stroke attributes."""
        # Determine which brush to use based on stroke color
        brush_id = self._determine_brush_from_color(stroke_color)
        
        # Calculate Z height based on stroke width
        z_height = self._calculate_z_height(stroke_width, brush_id)
        
        # Calculate feedrate based on opacity
        feedrate = self._calculate_feedrate(stroke_opacity, base_feedrate)
        
        # Add debug marker if enabled
        if self.debug_markers:
            self.output_lines.append(f"; Path with color: {stroke_color}, width: {stroke_width}, opacity: {stroke_opacity}")
            self.output_lines.append(f"; Using brush: {brush_id}, Z height: {z_height}mm, Feedrate: {feedrate}mm/min")
        
        # Select the brush
        self._select_brush(brush_id)
        
        # Process the path
        from .path_processor import PathProcessor
        points = PathProcessor.process_path(path_data)
        
        if not points:
            return
        
        # Move to the first point with Z up
        first_point = self._transform_point(points[0].x, points[0].y)
        self.output_lines.append(f"G1 Z10 F1000 ; Raise Z")
        self.output_lines.append(f"G1 X{first_point[0]:.3f} Y{first_point[1]:.3f} F3000 ; Move to start position")
        self.output_lines.append(f"G1 Z{z_height:.1f} F1000 ; Lower Z to drawing height")
        
        # Add the rest of the points
        for point in points[1:]:
            transformed = self._transform_point(point.x, point.y)
            self.output_lines.append(f"G1 X{transformed[0]:.3f} Y{transformed[1]:.3f} F{feedrate}")
        
        # Raise Z at the end of the path
        self.output_lines.append(f"G1 Z10 F1000 ; Raise Z")
    
    def _determine_brush_from_color(self, color):
        """Determine which brush to use based on color."""
        # Convert color to lowercase for comparison
        color = color.lower()
        
        # Check if it's a hex color
        if color.startswith('#'):
            # Parse hex color
            if len(color) == 7:  # #RRGGBB
                r = int(color[1:3], 16)
                g = int(color[3:5], 16)
                b = int(color[5:7], 16)
            elif len(color) == 4:  # #RGB
                r = int(color[1] + color[1], 16)
                g = int(color[2] + color[2], 16)
                b = int(color[3] + color[3], 16)
            else:
                # Default to brush_a for invalid hex
                return "brush_a"
            
            # Calculate brightness
            brightness = (r * 299 + g * 587 + b * 114) / 1000
            
            # Use brush_a for dark colors, brush_b for light colors
            return "brush_a" if brightness < 128 else "brush_b"
        
        # Handle named colors
        if color in ['black', 'darkgray', 'darkgrey', 'dimgray', 'dimgrey', 'gray', 'grey', 
                    'lightgray', 'lightgrey', 'navy', 'blue', 'darkblue', 'mediumblue', 
                    'darkgreen', 'green', 'darkolivegreen', 'forestgreen', 'seagreen', 
                    'darkslategray', 'darkslategrey', 'darkred', 'firebrick', 'brown', 
                    'maroon', 'saddlebrown', 'sienna', 'darkmagenta', 'indigo', 'midnightblue', 
                    'darkviolet', 'purple', 'rebeccapurple', 'darkslateblue']:
            return "brush_a"
        elif color in ['white', 'whitesmoke', 'snow', 'honeydew', 'mintcream', 'azure', 
                      'aliceblue', 'ghostwhite', 'lavenderblush', 'seashell', 'ivory', 
                      'floralwhite', 'linen', 'oldlace', 'cornsilk', 'papayawhip', 
                      'blanchedalmond', 'bisque', 'moccasin', 'navajowhite', 'peachpuff', 
                      'mistyrose', 'lavender', 'thistle', 'pink', 'lightpink', 'beige']:
            return "brush_b"
        
        # Default to brush_a
        return "brush_a"
    
    def _calculate_z_height(self, stroke_width, brush_id):
        """Calculate Z height based on stroke width."""
        base_height = self.brush_config[brush_id]["z_height"]
        
        # Scale stroke width to a reasonable Z height range
        # Thicker strokes = higher Z (less paint)
        z_adjustment = min(5.0, max(0.0, stroke_width - 1.0))
        
        return base_height + z_adjustment
    
    def _calculate_feedrate(self, opacity, base_feedrate):
        """Calculate feedrate based on opacity."""
        # Lower opacity = faster movement (less paint)
        # Higher opacity = slower movement (more paint)
        opacity_factor = max(0.5, min(1.5, 2.0 - opacity))
        
        return int(base_feedrate * opacity_factor)
    
    def _select_brush(self, brush_id):
        """Select a brush for drawing."""
        if brush_id == self.current_brush:
            return
        
        # Add brush change commands
        self.output_lines.append(f"; Changing brush to {brush_id}")
        self.output_lines.append(f"G1 Z10 F1000 ; Raise Z")
        
        # In a real implementation, this would include commands to change tools
        # For now, we just add a comment
        self.output_lines.append(f"; TOOL CHANGE: {brush_id}")
        
        # Update current brush
        self.current_brush = brush_id
    
    def _transform_point(self, x, y):
        """Transform a point from SVG coordinates to G-code coordinates."""
        # SVG coordinates start from top-left, G-code from bottom-left
        # We need to flip the Y coordinate
        
        # Calculate the scale factor
        svg_width = self.viewbox[2] - self.viewbox[0]
        svg_height = self.viewbox[3] - self.viewbox[1]
        
        # Apply viewBox transformation
        x_scaled = (x - self.viewbox[0]) / svg_width * self.width
        y_scaled = (y - self.viewbox[1]) / svg_height * self.height
        
        # Flip Y coordinate
        y_scaled = self.height - y_scaled
        
        # Apply user scale and offset
        x_final = x_scaled * self.scale + self.offset_x
        y_final = y_scaled * self.scale + self.offset_y
        
        return x_final, y_final
    
    def get_output(self):
        """Get the G-code output as a string."""
        return '\n'.join(self.output_lines) 