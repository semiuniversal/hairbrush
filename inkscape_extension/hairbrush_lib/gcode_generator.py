"""
G-code generation utilities for the hairbrush package.
"""

import re
import math
from .config import load_command_template
from .path_processor import PathProcessor


class GCodeGenerator:
    """Generator for G-code from SVG paths."""
    
    def __init__(self, template_name="default"):
        """
        Initialize the G-code generator.
        
        Args:
            template_name (str): Name of the command template to use
        """
        self.template = load_command_template(template_name)
        self.output_lines = []
        self.current_x = 0
        self.current_y = 0
        self.current_z = 0
        self.brush_config = {}
        self.svg_viewbox = None
        self.svg_width = None
        self.svg_height = None
        self.scale_factor = 1.0
        self.debug_markers = False
        self.machine_origin_x = 0
        self.machine_origin_y = 0
        self.machine_origin_z = 0
        self.skip_homing = False
        
        # Z-axis behavior parameters
        self.z_min = 1.0  # Minimum Z height for drawing in mm
        self.z_max = 15.0  # Maximum Z height for drawing in mm
        self.z_travel = 10.0  # Z height for travel moves in mm
        self.spray_cone_angle = 15.0  # Spray cone angle in degrees
        self.spray_cone_factor = math.tan(math.radians(self.spray_cone_angle / 2))
        
        # Z transformation parameters
        self.z_scale = 1.0  # Scaling factor for Z values
        self.z_offset = 0.0  # Offset for Z values
        
        # Current brush tracking
        self.current_brush = None
        self.current_z_height = None
        
    def add_header(self):
        """Add header G-code commands."""
        self.output_lines.extend([
            "; H.Airbrush Dual-Airbrush Plotter G-code",
            "; Generated by H.Airbrush Extension",
            "G90 ; Set absolute positioning",
            "G21 ; Set units to millimeters",
            "G17 ; Set working plane to X-Y (G17 = X-Y, G18 = X-Z, G19 = Y-Z)",
            "G28 ; Home all axes",
            "G92 X0 Y0 Z0 ; Set current position as origin",
            "M84 S0 ; Disable stepper timeout",
            "; Coordinate system: X right, Y forward, Z up",
            ""
        ])
        
    def add_footer(self):
        """Add footer G-code commands."""
        self.output_lines.extend([
            "",
            "; End of G-code",
            "G0 Z10 ; Raise Z",
            "G0 X0 Y0 ; Return to origin",
            "M84 ; Disable motors"
        ])
        
    def configure_brush(self, brush_id, config):
        """
        Configure a brush with specific settings.
        
        Args:
            brush_id (str): Brush identifier
            config (dict): Configuration for the brush
        """
        self.brush_config[brush_id] = config
        
    def add_brush_command(self, brush, command_type):
        """
        Add a brush command from the template.
        
        Args:
            brush (str): Brush identifier (e.g., 'brush_a')
            command_type (str): Command type (e.g., 'air_on', 'paint_on')
        """
        if brush in self.template and command_type in self.template[brush]:
            self.output_lines.append(self.template[brush][command_type])
        
    def add_move(self, x, y, z=None, feedrate=None, is_rapid=False):
        """
        Add a movement command.
        
        Args:
            x (float): X coordinate
            y (float): Y coordinate
            z (float, optional): Z coordinate
            feedrate (float, optional): Feedrate in mm/min
            is_rapid (bool): Whether to use rapid movement (G0)
        """
        command = "G0" if is_rapid else "G1"
        
        coords = []
        if x is not None and x != self.current_x:
            coords.append(f"X{x:.3f}")
            self.current_x = x
        if y is not None and y != self.current_y:
            coords.append(f"Y{y:.3f}")
            self.current_y = y
        if z is not None and z != self.current_z:
            coords.append(f"Z{z:.3f}")
            self.current_z = z
            
        if feedrate is not None:
            coords.append(f"F{feedrate}")
            
        if coords:
            self.output_lines.append(f"{command} {' '.join(coords)}")
    
    def parse_path_commands(self, path_data):
        """
        Parse SVG path data into a list of commands.
        
        Args:
            path_data (str): SVG path data
            
        Returns:
            list: List of (command, [params]) tuples
        """
        # Regular expression to match path commands and parameters
        command_regex = r"([MLHVCSQTAZmlhvcsqtaz])([^MLHVCSQTAZmlhvcsqtaz]*)"
        
        # Find all commands and their parameters
        commands = []
        for match in re.finditer(command_regex, path_data):
            cmd = match.group(1)
            params_str = match.group(2).strip()
            
            # Parse parameters
            params = []
            if params_str:
                # Split by either commas or spaces
                params_parts = re.split(r"[\s,]+", params_str)
                # Convert to float
                params = [float(p) for p in params_parts if p]
            
            commands.append((cmd, params))
            
        return commands
    
    def set_svg_document_properties(self, viewbox=None, width=None, height=None):
        """
        Set SVG document properties for proper scaling.
        
        Args:
            viewbox (tuple): SVG viewBox as (min_x, min_y, width, height)
            width (float): SVG document width
            height (float): SVG document height
        """
        self.svg_viewbox = viewbox
        self.svg_width = width
        self.svg_height = height
        
        # Calculate scale factor if we have both viewBox and dimensions
        if viewbox and (width is not None or height is not None):
            if width is not None:
                self.scale_factor = width / viewbox[2]
            else:
                self.scale_factor = height / viewbox[3]
                
        # Add info to output
        if viewbox:
            self.output_lines.append(f"; SVG viewBox: {viewbox}")
        if width is not None:
            self.output_lines.append(f"; SVG width: {width}")
        if height is not None:
            self.output_lines.append(f"; SVG height: {height}")
        if self.scale_factor != 1.0:
            self.output_lines.append(f"; Scale factor: {self.scale_factor}")
    
    def enable_debug_markers(self, enable=True):
        """
        Enable or disable debug markers in the G-code.
        
        Args:
            enable (bool): Whether to enable debug markers
        """
        self.debug_markers = enable
    
    def transform_coordinates(self, x, y):
        """
        Transform SVG coordinates to G-code coordinates.
        
        This method handles the conversion from SVG coordinate space (origin at top-left)
        to G-code coordinate space (origin at bottom-left or machine origin).
        It applies viewBox transformations, SVG units conversion, and coordinate system flipping.
        
        Args:
            x (float): SVG X coordinate
            y (float): SVG Y coordinate
            
        Returns:
            tuple: (x, y) in G-code coordinate space
        """
        # Store original coordinates for debugging
        orig_x, orig_y = x, y
        
        # Apply viewBox transformation if available
        if self.svg_viewbox:
            min_x, min_y, vb_width, vb_height = self.svg_viewbox
            
            # First, adjust for viewBox origin
            x = x - min_x
            y = y - min_y
        
        # Apply document scaling if we have dimensions
        if self.svg_width is not None and self.svg_height is not None:
            # Calculate scaling factors
            if self.svg_viewbox:
                # If we have a viewBox, scale from viewBox to document dimensions
                scale_x = self.svg_width / self.svg_viewbox[2]
                scale_y = self.svg_height / self.svg_viewbox[3]
            else:
                # If no viewBox, use the scale factor directly
                scale_x = self.scale_factor
                scale_y = self.scale_factor
                
            # Apply scaling
            x = x * scale_x
            y = y * scale_y
            
            # SVG has Y axis pointing down, G-code has Y axis pointing up
            # Invert Y coordinate to ensure proper alignment to X-Y plane
            y = self.svg_height - y
        
        # Apply user-defined scale factor (for unit conversion or resizing)
        if hasattr(self, 'user_scale_factor') and self.user_scale_factor != 1.0:
            x = x * self.user_scale_factor
            y = y * self.user_scale_factor
            
        # Apply user-defined offset (for positioning on the machine)
        if hasattr(self, 'user_offset_x') and hasattr(self, 'user_offset_y'):
            x = x + self.user_offset_x
            y = y + self.user_offset_y
        
        # Debug comments disabled by default
        # if hasattr(self, 'debug_markers') and self.debug_markers:
        #     self.output_lines.append(f"; Coordinate transform: ({orig_x:.2f},{orig_y:.2f}) -> ({x:.2f},{y:.2f})")
            
        # Ensure coordinates are properly rounded to avoid floating point issues
        x = round(x, 3)
        y = round(y, 3)
        
        # Force alignment to X-Y plane by ensuring no correlation between coordinates
        # This prevents any slant in the X-Z or Y-Z planes
        return x, y
    
    def transform_z(self, z):
        """
        Transform Z coordinate from artistic value to machine value.
        
        This ensures that Z values are properly transformed with no correlation to X or Y,
        preventing any slant in the Y-Z plane.
        
        Args:
            z (float): Z coordinate to transform
            
        Returns:
            float: Transformed Z coordinate
        """
        # Apply a Z offset if configured
        z_offset = getattr(self, 'z_offset', 0.0)
        
        # Apply Z scaling if configured
        z_scale = getattr(self, 'z_scale', 1.0)
        
        # Apply transformation
        transformed_z = z * z_scale + z_offset
        
        # Ensure Z is within safe limits
        min_z = getattr(self, 'z_min', 0.0)
        max_z = getattr(self, 'z_max', 20.0)
        transformed_z = max(min_z, min(transformed_z, max_z))
        
        return transformed_z
        
    def add_path(self, path_data, brush, z_height, feedrate, curve_resolution=20, paint_flow=1.0):
        """
        Add G-code for a path.
        
        This method converts SVG path data to a series of G-code movements,
        ensuring proper separation of Z and XY movements to maintain a flat drawing plane.
        
        Args:
            path_data (str): SVG path data
            brush (str): Brush identifier (e.g., 'brush_a')
            z_height (float): Z height for the path
            feedrate (float): Feedrate in mm/min
            curve_resolution (int): Number of segments to use for curves
            paint_flow (float): Paint flow value (0.0-1.0)
        """
        # Parse the path data using the path processor
        path_segments = PathProcessor.parse_path(path_data)
        if not path_segments:
            return
        
        # Convert path to polyline with the specified curve resolution
        polyline = PathProcessor.path_to_polyline(path_segments, curve_resolution=curve_resolution)
        if not polyline:
            return
            
        # Apply brush offset if configured
        offset_x = 0
        offset_y = 0
        if brush in self.brush_config and "offset" in self.brush_config[brush]:
            offset_x, offset_y = self.brush_config[brush]["offset"]
        
        # Get brush index (0 for brush_a, 1 for brush_b) and label
        brush_index = 0 if brush == "brush_a" else 1
        brush_label = "Brush A (black)" if brush == "brush_a" else "Brush B (white)"
        
        # Add a comment to indicate the path's Z height and brush
        self.output_lines.append(f"; Path with {brush_label} at Z={z_height:.2f}mm")
        
        # Transform z_height
        transformed_z = self.transform_z(z_height)
        
        # Use configured travel height if available, otherwise use default offset
        travel_z = getattr(self, 'z_travel', 10.0)
        
        # STEP 1: Raise Z to travel height (G0 for rapid movement)
        self.output_lines.append("G0 Z{:.2f} F3000".format(travel_z))
        self.output_lines.append("M400 ; Wait for Z movement to complete")
        
        # STEP 2: Move XY to start point with Z raised (G0 for rapid movement)
        first_point = polyline[0]
        x, y = self.transform_coordinates(first_point[0], first_point[1])
        self.output_lines.append("G0 X{:.2f} Y{:.2f} F3000".format(x + offset_x, y + offset_y))
        self.output_lines.append("M400 ; Wait for XY movement to complete")
        
        # STEP 3: Lower Z to drawing height (G1 for controlled movement)
        self.output_lines.append("G1 Z{:.2f} F1500".format(transformed_z))
        self.output_lines.append("M400 ; Wait for Z movement to complete")
        
        # STEP 4: Turn on airbrush
        servo_angle = int((math.sqrt(paint_flow) * 170) + 10)  # Range 10-180
        self.output_lines.append(f"M42 P{brush_index} S1 ; Air on")
        self.output_lines.append(f"M280 P{brush_index} S{servo_angle} ; Trigger")
        
        # STEP 5: Set feedrate for drawing movements
        self.output_lines.append(f"G1 F{feedrate}")
        
        # STEP 6: Draw path with XY movements only (Z remains constant)
        for point in polyline[1:]:
            x, y = self.transform_coordinates(point[0], point[1])
            self.output_lines.append("G1 X{:.2f} Y{:.2f}".format(x + offset_x, y + offset_y))
        
        # Add M400 after completing the drawing path
        self.output_lines.append("M400 ; Wait for drawing to complete")
        
        # STEP 7: Turn off airbrush
        self.output_lines.append(f"M280 P{brush_index} S0 ; Release trigger")
        self.output_lines.append(f"M42 P{brush_index} S0 ; Air off")
        
        # STEP 8: Raise Z to travel height (G0 for rapid movement)
        self.output_lines.append("G0 Z{:.2f} F3000".format(travel_z))
        self.output_lines.append("M400 ; Wait for Z movement to complete")

    def generate_gcode(self, include_test_pattern=False):
        """
        Generate G-code for all added paths.
        
        Args:
            include_test_pattern (bool): Whether to include a test pattern for X-Y plane verification
            
        Returns:
            str: The complete G-code
        """
        # Add file header with version and timestamp
        import datetime
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.output_lines.insert(0, f"; H.Airbrush Dual-Airbrush Plotter G-code")
        self.output_lines.insert(1, f"; Generated: {timestamp}")
        self.output_lines.insert(2, f"; CoreXY-H Plotter with Duet 2 WiFi")
        
        # Add header template if available
        if "header" in self.template:
            self.output_lines.append(self.template["header"])
            
        # Add machine initialization
        self.add_machine_initialization()
        
        # Add initialization template if available
        if "init" in self.template:
            self.output_lines.append(self.template["init"])
        
        # Add test pattern if requested
        if include_test_pattern:
            self.add_xy_plane_test_pattern()
            
        # Add footer with machine cleanup
        self.output_lines.append("; MACHINE CLEANUP")
        
        # Raise Z to safe height
        self.output_lines.append("G0 Z10 F3000")
        
        # Return XY to origin
        self.output_lines.append("G0 X0 Y0 F3000")
        
        # Ensure all airbrush systems are off
        self.output_lines.append("M280 P0 S0 ; Brush A trigger off")
        self.output_lines.append("M280 P1 S0 ; Brush B trigger off")
        self.output_lines.append("M42 P0 S0 ; Brush A air off")
        self.output_lines.append("M42 P1 S0 ; Brush B air off")
        
        # Add footer template if available
        if "footer" in self.template:
            self.output_lines.append(self.template["footer"])
            
        # Final comment
        self.output_lines.append("; End of G-code")
        
        # Join all lines with newlines
        return "\n".join(self.output_lines)

    def set_machine_origin(self, x=0, y=0, z=0):
        """
        Set the machine origin coordinates.
        
        This affects the G92 command that will be included in the G-code output.
        
        Args:
            x (float): X coordinate of machine origin
            y (float): Y coordinate of machine origin
            z (float): Z coordinate of machine origin
        """
        self.machine_origin_x = x
        self.machine_origin_y = y
        self.machine_origin_z = z
        
        # Add info to output
        self.output_lines.append(f"; Machine origin set to X{x:.3f} Y{y:.3f} Z{z:.3f}")
        
    def set_skip_homing(self, skip=True):
        """
        Set whether to skip the homing command.
        
        Args:
            skip (bool): Whether to skip the homing command
        """
        self.skip_homing = skip

    def configure_z_behavior(self, min_height=1.0, max_height=15.0, travel_height=10.0, spray_cone_angle=15.0):
        """
        Configure Z-axis behavior for the airbrush.
        
        This method allows fine-tuning of the Z-axis parameters based on the specific
        machine configuration and airbrush characteristics.
        
        Args:
            min_height (float): Minimum Z height for drawing in mm
            max_height (float): Maximum Z height for drawing in mm
            travel_height (float): Z height for travel moves in mm
            spray_cone_angle (float): Spray cone angle in degrees
        """
        self.z_min = min_height
        self.z_max = max_height
        self.z_travel = travel_height
        self.spray_cone_angle = spray_cone_angle
        
        # Calculate spray cone factor from angle
        self.spray_cone_factor = math.tan(math.radians(spray_cone_angle / 2))
        
        # Add configuration info to output
        self.output_lines.append("; ===== Z-AXIS CONFIGURATION =====")
        self.output_lines.append(f"; Min Z height: {min_height}mm")
        self.output_lines.append(f"; Max Z height: {max_height}mm")
        self.output_lines.append(f"; Travel Z height: {travel_height}mm")
        self.output_lines.append(f"; Spray cone angle: {spray_cone_angle}Â°")
        self.output_lines.append(f"; Spray cone factor: {self.spray_cone_factor:.4f}")
        self.output_lines.append("")

    def add_working_plane_alignment(self):
        """
        Add G-code to explicitly set and align the working plane.
        
        This ensures that all drawing happens in the true X-Y plane with no slant.
        Optimized to minimize Z-axis movements which are significantly slower.
        """
        self.output_lines.append("; ===== WORKING PLANE ALIGNMENT =====")
        
        # Set working plane to X-Y plane (G17)
        self.output_lines.append("G17 ; Set working plane to X-Y (G17 = X-Y, G18 = X-Z, G19 = Y-Z)")
        
        # Set absolute positioning
        self.output_lines.append("G90 ; Set absolute positioning")
        
        # Set units to millimeters
        self.output_lines.append("G21 ; Set units to millimeters")
        
        # Move to origin with Z raised (single Z movement)
        self.output_lines.append("G0 Z10 F3000 ; Raise Z to safe height")
        self.output_lines.append("G0 X0 Y0 F3000 ; Move to XY origin")
        
        # Reset coordinate system to ensure no slant
        self.output_lines.append("G92 X0 Y0 Z10 ; Set current position as origin")
        
        # Move to Z=0 once (single Z movement)
        self.output_lines.append("G0 Z0 F1500 ; Move to Z=0 to establish true XY plane")
        self.output_lines.append("G92 Z0 ; Set Z=0 at this position")
        
        # Define the X-Y plane by moving to three points at exactly Z=0
        # All XY movements with Z staying at 0
        self.output_lines.append("; Define X-Y plane with three points at Z=0 (keeping Z at 0)")
        
        # Already at origin with Z=0
        self.output_lines.append("G92 X0 Y0 Z0 ; Reset coordinate system at origin")
        
        # Move to X-axis reference (only XY movement)
        self.output_lines.append("G0 X100 Y0 F3000 ; Point 2: X-axis reference")
        self.output_lines.append("G92 X100 Y0 Z0 ; Ensure Z=0 at this point")
        
        # Move to Y-axis reference (only XY movement)
        self.output_lines.append("G0 X0 Y100 F3000 ; Point 3: Y-axis reference")
        self.output_lines.append("G92 X0 Y100 Z0 ; Ensure Z=0 at this point")
        
        # Return to origin (only XY movement)
        self.output_lines.append("G0 X0 Y0 F3000 ; Return to origin")
        self.output_lines.append("G92 X0 Y0 Z0 ; Final reset of coordinate system")
        
        # Move back to safe height (single Z movement)
        self.output_lines.append("G0 Z10 F3000 ; Return to safe height")
        
        self.output_lines.append("; ===== END WORKING PLANE ALIGNMENT =====")
        self.output_lines.append("")

    def set_z_transformation(self, scale=1.0, offset=0.0):
        """
        Set Z transformation parameters.
        
        This allows fine-tuning of the Z-axis behavior by applying scaling and offset
        to all Z values.
        
        Args:
            scale (float): Scaling factor for Z values
            offset (float): Offset for Z values in mm
        """
        self.z_scale = scale
        self.z_offset = offset
        
        # Add configuration info to output
        self.output_lines.append("; ===== Z TRANSFORMATION =====")
        self.output_lines.append(f"; Z scale: {scale}")
        self.output_lines.append(f"; Z offset: {offset}mm")
        self.output_lines.append("")

    def add_xy_plane_test_pattern(self):
        """
        Add G-code for a test pattern to verify X-Y plane alignment.
        """
        self.output_lines.append("; XY PLANE TEST PATTERN")
        
        # Set a constant Z height for the entire pattern
        test_z = 1.0
        travel_z = 10.0
        
        # Move to safe height and origin
        self.output_lines.append("G0 Z{:.1f} F3000".format(travel_z))
        self.output_lines.append("G0 X0 Y0 F3000")
        
        # Lower Z for drawing
        self.output_lines.append("G1 Z{:.1f} F1500".format(test_z))
        
        # Draw horizontal lines
        for y in range(0, 101, 25):
            if y == 0:
                self.output_lines.append("G1 X100 Y0 F1500")
            else:
                self.output_lines.append("G0 X0 Y{} F3000".format(y))
                self.output_lines.append("G1 X100 Y{} F1500".format(y))
        
        # Draw vertical lines
        for x in range(0, 101, 25):
            if x == 0:
                self.output_lines.append("G0 X0 Y0 F3000")
                self.output_lines.append("G1 X0 Y100 F1500")
            else:
                self.output_lines.append("G0 X{} Y0 F3000".format(x))
                self.output_lines.append("G1 X{} Y100 F1500".format(x))
        
        # Draw diagonal lines
        self.output_lines.append("G0 X0 Y0 F3000")
        self.output_lines.append("G1 X100 Y100 F1500")
        self.output_lines.append("G0 X0 Y100 F3000")
        self.output_lines.append("G1 X100 Y0 F1500")
        
        # Return to safe position
        self.output_lines.append("G0 Z{:.1f} F3000".format(travel_z))
        self.output_lines.append("G0 X0 Y0 F3000")

    def get_output(self):
        """
        Get the generated G-code.
        
        Returns:
            str: The complete G-code
        """
        return "\n".join(self.output_lines)
    
    def save_to_file(self, filename):
        """
        Save the G-code to a file.
        
        Args:
            filename (str): Output filename
        """
        with open(filename, "w") as f:
            f.write(self.get_output())
    
    def set_user_transform(self, scale_factor=1.0, offset_x=0.0, offset_y=0.0):
        """
        Set user-defined transformation parameters.
        
        These parameters allow for additional scaling and positioning of the output.
        
        Args:
            scale_factor (float): Additional scaling factor to apply
            offset_x (float): X offset to apply after all other transformations
            offset_y (float): Y offset to apply after all other transformations
        """
        self.user_scale_factor = scale_factor
        self.user_offset_x = offset_x
        self.user_offset_y = offset_y
        
        # Add info to output
        self.output_lines.append(f"; User scale factor: {scale_factor}")
        self.output_lines.append(f"; User offset: X{offset_x:.3f} Y{offset_y:.3f}")
    
    def calculate_airbrush_parameters(self, stroke_width, stroke_opacity):
        """
        Calculate optimal Z-height, paint flow, and feedrate based on stroke width and opacity.
        
        This model accounts for the physics of airbrush operation:
        1. Conical spray pattern where distance affects both width and density
        2. Paint flow control affects color intensity independently of width
        3. Movement speed affects saturation (slower = more paint in one area)
        
        The model optimizes these three parameters to achieve the desired stroke
        width and opacity while maintaining consistent quality.
        
        Args:
            stroke_width (float): Desired stroke width in mm
            stroke_opacity (float): Desired stroke opacity (0.0-1.0)
            
        Returns:
            tuple: (z_height, paint_flow, feedrate_factor)
        """
        # Use configured Z parameters if available, otherwise use defaults
        z_min = getattr(self, 'z_min', 1.0)
        z_max = getattr(self, 'z_max', 15.0)
        spray_cone_factor = getattr(self, 'spray_cone_factor', 
                                   math.tan(math.radians(15.0 / 2)))
        
        # System constraints
        flow_min, flow_max = 0.1, 1.0  # Normalized paint flow range
        speed_min, speed_max = 0.2, 1.0  # Normalized speed factor range
        
        # Density falloff with distance (inverse power law approximation)
        density_falloff_exponent = 1.8  # Slightly less than 2 for real-world behavior
        
        # Step 1: Calculate optimal Z height based on desired width
        # Formula: Z = width / (2 * tan(cone_angle/2))
        z_from_width = stroke_width / (2 * spray_cone_factor)
        
        # Clamp Z to our allowed range
        z_height = min(max(z_from_width, z_min), z_max)
        
        # Step 2: Calculate actual width at this Z height
        actual_width = 2 * z_height * spray_cone_factor
        
        # Step 3: Calculate Z's effect on density (inverse power law)
        # At z_min, factor = 1.0; at z_max, factor = (z_min/z_max)^exponent
        z_density_factor = (z_min / z_height) ** density_falloff_exponent
        
        # Step 4: Calculate required opacity compensation
        # This is how much we need to adjust paint flow and speed to achieve desired opacity
        required_opacity = stroke_opacity / z_density_factor
        required_opacity = min(max(required_opacity, 0.0), 1.0)  # Clamp to valid range
        
        # Step 5: Determine optimal paint flow and speed combination
        # For high opacity needs: increase flow, decrease speed
        # For low opacity needs: decrease flow, can use higher speed
        
        # Paint flow calculation - use non-linear mapping for more natural response
        # Square root curve gives more granular control in lower opacity range
        paint_flow = flow_min + (math.sqrt(required_opacity) * (flow_max - flow_min))
        
        # Speed calculation - slower for higher opacity needs
        # Use quadratic curve for more natural response
        speed_factor = speed_max - (required_opacity**2 * (speed_max - speed_min))
        
        # Step 6: Adjust for width vs. expected width
        # If we couldn't achieve exact width due to Z constraints, compensate with speed
        width_compensation = stroke_width / actual_width if actual_width > 0 else 1.0
        width_compensation = min(max(width_compensation, 0.8), 1.2)  # Limit compensation
        speed_factor *= width_compensation
        
        # Add debug information as comments
        self.output_lines.append(f"; AIRBRUSH PHYSICS: z_density={z_density_factor:.3f}, req_opacity={required_opacity:.3f}")
        self.output_lines.append(f"; WIDTH: requested={stroke_width:.2f}mm, actual={actual_width:.2f}mm, compensation={width_compensation:.3f}")
        
        return z_height, paint_flow, speed_factor

    def add_machine_initialization(self):
        """
        Add G-code for machine initialization specific to the dual-airbrush plotter.
        """
        self.output_lines.append("; MACHINE INITIALIZATION")
        
        # Basic machine setup
        self.output_lines.append("M451 ; CNC mode")
        self.output_lines.append("G17 ; X-Y plane")
        self.output_lines.append("G21 ; mm units")
        self.output_lines.append("G90 ; Absolute positioning")
        
        # Home if not skipped
        if not hasattr(self, 'skip_homing') or not self.skip_homing:
            self.output_lines.append("G28 ; Home all axes")
        
        # Initialize coordinate system with minimal Z movements
        self.output_lines.append("G0 Z10 F3000")
        self.output_lines.append("G0 X0 Y0 F3000")
        self.output_lines.append("G92 X0 Y0 Z10 ; Set origin")
        self.output_lines.append("G0 Z0 F1500")
        self.output_lines.append("G92 Z0 ; Set Z=0")
        self.output_lines.append("G0 Z10 F3000")
            
        # Disable stepper timeout
        self.output_lines.append("M84 S0 ; No stepper timeout")
        
        # Initialize airbrush systems
        self.output_lines.append("M280 P0 S0 ; Brush A trigger off")
        self.output_lines.append("M280 P1 S0 ; Brush B trigger off")
        self.output_lines.append("M42 P0 S0 ; Brush A air off")
        self.output_lines.append("M42 P1 S0 ; Brush B air off")

    def add_path_with_attributes(self, path_data, stroke_color, stroke_width, stroke_opacity, base_feedrate=1500, curve_resolution=20):
        """
        Add G-code for a stroke path with artistic parameters.
        
        This method translates SVG stroke attributes into appropriate airbrush settings
        by calculating optimal Z-height, paint flow, and movement speed based on the
        physics of airbrush operation.
        
        Args:
            path_data (str): SVG path data
            stroke_color (str): Stroke color (e.g., "black", "white", "#ff0000")
            stroke_width (float): Stroke width in mm
            stroke_opacity (float): Stroke opacity (0.0-1.0)
            base_feedrate (float): Base feedrate in mm/min
            curve_resolution (int): Number of segments to use for curves
        """
        # Select tool based on stroke color
        brush = "brush_a"  # Default to brush_a (black)
        brush_index = 0
        
        # Map common color names to brush selection
        if stroke_color.lower() in ["#ffffff", "white"]:
            brush = "brush_b"  # Use brush_b for white
            brush_index = 1
        elif stroke_color.lower() in ["#ff0000", "red"]:
            brush = "brush_b"  # Example: map red to brush_b
            brush_index = 1
            
        # Calculate parameters for airbrush based on stroke attributes
        z_height, paint_flow, speed_factor = self.calculate_airbrush_parameters(stroke_width, stroke_opacity)
        feedrate = base_feedrate * speed_factor
        
        # Add detailed stroke information as comments
        self.output_lines.append(f"; ===== STROKE PARAMETERS =====")
        self.output_lines.append(f"; Color: {stroke_color}")
        self.output_lines.append(f"; Width: {stroke_width:.2f}mm")
        self.output_lines.append(f"; Opacity: {stroke_opacity:.2f}")
        self.output_lines.append(f"; Brush: {brush} (index {brush_index})")
        
        # Add airbrush settings as comments
        self.output_lines.append(f"; ===== AIRBRUSH SETTINGS =====")
        self.output_lines.append(f"; Z-height: {z_height:.2f}mm")
        self.output_lines.append(f"; Paint flow: {paint_flow:.2f}")
        self.output_lines.append(f"; Feedrate: {feedrate:.0f}mm/min (factor: {speed_factor:.2f})")
        
        # Add the path directly
        self.add_path(path_data, brush, z_height, feedrate, curve_resolution=curve_resolution, paint_flow=paint_flow) 